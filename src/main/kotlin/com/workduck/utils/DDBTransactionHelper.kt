package com.workduck.utils

import com.amazonaws.AmazonWebServiceRequest
import com.amazonaws.SdkClientException
import com.amazonaws.services.dynamodbv2.AmazonDynamoDBClientBuilder
import com.amazonaws.services.dynamodbv2.datamodeling.*
import com.amazonaws.services.dynamodbv2.model.*
import com.amazonaws.util.VersionInfoUtils
import java.util.*

/**
 * This is a custom helper for transactions ( code taken from DynamoDBMapper.java class ).
 * Due to some inconsistencies with aws library for transactions, we're using this helper to tweak the code as per our own use case.
 * Bug reported : https://github.com/aws/aws-sdk-java/issues/2664
 * Use cases this helper solves :  using dynamic table names for different configs, adhering save to specific save behaviour etc.
 * @author Varun Garg
 */
class DDBTransactionHelper(
    private val mapper: DynamoDBMapper
) {

    private val USER_AGENT_TRANSACTION_OPERATION = DynamoDBMapper::class.java.name + "_transaction_operation/" + VersionInfoUtils.getVersion()

    private class ValueUpdate(
        private val field: DynamoDBMapperFieldModel<Any, Any>,
        private val newValue: AttributeValue,
        private val target: Any
    ) {
        fun apply() {
            field[target] = field.unconvert(newValue)
        }
    }

    fun transactionWrite(transactionWriteRequest: TransactionWriteRequest?, config: DynamoDBMapperConfig) {
        if (transactionWriteRequest == null || transactionWriteRequest.transactionWriteOperations.isNullOrEmpty()) {
            throw SdkClientException("Input request is null or empty")
        }
        val finalConfig: DynamoDBMapperConfig = config
        val writeOperations = transactionWriteRequest.transactionWriteOperations
        val inMemoryUpdates: MutableList<ValueUpdate> = LinkedList()
        val transactWriteItemsRequest = TransactWriteItemsRequest()
        val transactWriteItems: MutableList<TransactWriteItem> = ArrayList()
        transactWriteItemsRequest.clientRequestToken = transactionWriteRequest.idempotencyToken
        for ((index, writeOperation) in writeOperations.withIndex()) {
            transactWriteItems.add(
                generateTransactWriteItem(
                    writeOperation,
                    inMemoryUpdates,
                        finalConfig
                )
            )
        }
        transactWriteItemsRequest.setTransactItems(transactWriteItems)

        /* directly using the class here */
        val db = AmazonDynamoDBClientBuilder.defaultClient()
        db.transactWriteItems(applyTransactionOperationUserAgent(transactWriteItemsRequest))

        // Update the inMemory values for autogenerated attributeValues after successful completion of transaction
        for (update in inMemoryUpdates) {
            update.apply()
        }
    }

    private fun <X : AmazonWebServiceRequest?> applyTransactionOperationUserAgent(request: X): X {
        request!!.requestClientOptions.appendUserAgent(USER_AGENT_TRANSACTION_OPERATION)
        return request
    }

    private fun generateTransactWriteItem(
        transactionWriteOperation: TransactionWriteRequest.TransactionWriteOperation,
        inMemoryUpdates: MutableList<ValueUpdate>,
        config: DynamoDBMapperConfig?
    ): TransactWriteItem {
        val objectToWrite = transactionWriteOperation.getObject()
        var writeExpression = transactionWriteOperation.dynamoDBTransactionWriteExpression
        val returnValuesOnConditionCheckFailure = transactionWriteOperation.returnValuesOnConditionCheckFailure
        val operationType = transactionWriteOperation.transactionWriteOperationType
        val clazz = objectToWrite.javaClass as Class<Any>
        val tableName: String = getTableName(clazz, objectToWrite, config)
        val attributeValues: MutableMap<String, AttributeValue> = HashMap()
        val model: DynamoDBMapperTableModel<Any> = mapper.getTableModel<Any>(clazz, config)
        val versionAttributeConditionExpressionGenerator = VersionAttributeConditionExpressionGenerator()
        for (field in model.fields()) {
            var currentValue: AttributeValue? = null
            if (field.versioned()) {
                if (writeExpression != null) {
                    throw SdkClientException(
                        "A transactional write operation may not also specify a condition " +
                            "expression if a versioned attribute is present on the " +
                            "model of the item."
                    )
                } else {
                    val fieldValue = field[objectToWrite]
                    versionAttributeConditionExpressionGenerator
                        .appendVersionAttributeToConditionExpression(
                            field,
                            fieldValue
                        )
                    currentValue = field.convert(field.generate(field[objectToWrite]))
                    inMemoryUpdates.add(ValueUpdate(field, currentValue, objectToWrite))
                }
            } else if (canGenerate(model, objectToWrite, DynamoDBMapperConfig.SaveBehavior.CLOBBER, field)) {
                currentValue = field.convert(field.generate(field[objectToWrite]))
                inMemoryUpdates.add(ValueUpdate(field, currentValue, objectToWrite))
            } else {
                currentValue = field.convert(field[objectToWrite])
            }
            if (currentValue == null && field.keyType() != null) {
                throw DynamoDBMappingException(clazz.simpleName + "[" + field.name() + "]; null or empty value for primary key")
            } else if (currentValue != null) {
                attributeValues[field.name()] = currentValue
            }
        }
        val versionAttributeConditionExpression = versionAttributeConditionExpressionGenerator.versionAttributeConditionExpression
        if (versionAttributeConditionExpression.conditionExpression != null) {
            writeExpression = versionAttributeConditionExpression
        }
        val parameters: AttributeTransformer.Parameters<Any>? = toParameters<Any>(attributeValues, clazz, tableName, config)
        val attributeValueMap: Map<String, AttributeValue> = transformAttributes(parameters)
        val transactWriteItem = TransactWriteItem()
        when (operationType) {
            TransactionWriteRequest.TransactionWriteOperationType.Put -> transactWriteItem.put = generatePut(tableName, attributeValueMap, returnValuesOnConditionCheckFailure, writeExpression)
            TransactionWriteRequest.TransactionWriteOperationType.Update -> transactWriteItem.update = generateUpdate(model, tableName, attributeValueMap, returnValuesOnConditionCheckFailure, writeExpression)
            TransactionWriteRequest.TransactionWriteOperationType.ConditionCheck -> transactWriteItem.conditionCheck = generateConditionCheck(model, tableName, objectToWrite, returnValuesOnConditionCheckFailure, writeExpression)
            TransactionWriteRequest.TransactionWriteOperationType.Delete -> transactWriteItem.delete = generateDelete(model, tableName, objectToWrite, returnValuesOnConditionCheckFailure, writeExpression)
            else -> throw UnsupportedOperationException("Unsupported operationType: " + operationType + " for object: " + model.convertKey<Any, Any>(objectToWrite) + " of type: " + clazz)
        }
        return transactWriteItem
    }

    private fun generatePut(
        tableName: String,
        attributeValueMap: Map<String, AttributeValue>,
        returnValuesOnConditionCheckFailure: ReturnValuesOnConditionCheckFailure?,
        writeExpression: DynamoDBTransactionWriteExpression?
    ): Put? {
        val put = Put()
        put.item = attributeValueMap
        put.tableName = tableName
        if (returnValuesOnConditionCheckFailure != null) {
            put.returnValuesOnConditionCheckFailure = returnValuesOnConditionCheckFailure.toString()
        }
        if (writeExpression != null) {
            if (writeExpression.conditionExpression != null) {
                put.conditionExpression = writeExpression.conditionExpression
            }
            if (!writeExpression.expressionAttributeNames.isNullOrEmpty()) {
                put.expressionAttributeNames = writeExpression.expressionAttributeNames
            }
            if (!writeExpression.expressionAttributeValues.isNullOrEmpty()) {
                put.expressionAttributeValues = writeExpression.expressionAttributeValues
            }
        }
        return put
    }

    private fun generateUpdate(
        model: DynamoDBMapperTableModel<Any>,
        tableName: String,
        attributeValueMap: Map<String, AttributeValue>,
        returnValuesOnConditionCheckFailure: ReturnValuesOnConditionCheckFailure?,
        writeExpression: DynamoDBTransactionWriteExpression?
    ): Update? {
        val update = Update()
        val expressionAttributeNamesMap: MutableMap<String, String> = HashMap()
        val expressionsAttributeValuesMap: MutableMap<String, AttributeValue> = HashMap()
        if (returnValuesOnConditionCheckFailure != null) {
            update.returnValuesOnConditionCheckFailure = returnValuesOnConditionCheckFailure.toString()
        }
        if (writeExpression != null) {
            if (writeExpression.conditionExpression != null) {
                update.conditionExpression = writeExpression.conditionExpression
            }
            if (!writeExpression.expressionAttributeNames.isNullOrEmpty()) {
                expressionAttributeNamesMap.putAll(writeExpression.expressionAttributeNames)
            }
            if (!writeExpression.expressionAttributeValues.isNullOrEmpty()) {
                expressionsAttributeValuesMap.putAll(writeExpression.expressionAttributeValues)
            }
        }
        val keyAttributeValueMap: MutableMap<String, AttributeValue?> = HashMap()
        // Copy attributeValueMap
        val nonKeyNonNullAttributeValueMap: MutableMap<String, AttributeValue> = HashMap(attributeValueMap)
        // These are the non-key attributes that are present in the model and not in the customer object,
        // meaning they're to be removed in this update
        val nullValuedNonKeyAttributeNames: MutableList<String> = ArrayList()

        // Categorize modeled fields as key, non-key, and removed
        for (field in model.fields()) {
            if (field.keyType() != null) {
                keyAttributeValueMap[field.name()] = nonKeyNonNullAttributeValueMap.remove(field.name())
            } else if (nonKeyNonNullAttributeValueMap[field.name()] == null) {
                /* Uncomment below line to remove current null fields of model from DDB Table */
                // nullValuedNonKeyAttributeNames.add(field.name())
                nonKeyNonNullAttributeValueMap.remove(field.name())
            }
        }

        // Categorize null non-modeled fields (using iterator to avoid ConcurrentModificationException)
        val iterator = nonKeyNonNullAttributeValueMap.keys.iterator()
        while (iterator.hasNext()) {
            val key = iterator.next()
            if (nonKeyNonNullAttributeValueMap[key] == null) {
                nullValuedNonKeyAttributeNames.add(key)
                iterator.remove()
            }
        }
        update.tableName = tableName
        update.updateExpression = UpdateExpressionGenerator()
            .generateUpdateExpressionAndUpdateAttributeMaps(
                expressionAttributeNamesMap,
                expressionsAttributeValuesMap,
                nonKeyNonNullAttributeValueMap,
                nullValuedNonKeyAttributeNames
            )
        update.key = keyAttributeValueMap
        if (expressionAttributeNamesMap.isNotEmpty()) {
            update.expressionAttributeNames = expressionAttributeNamesMap
        }
        if (expressionsAttributeValuesMap.isNotEmpty()) {
            update.expressionAttributeValues = expressionsAttributeValuesMap
        }
        return update
    }

    private fun generateConditionCheck(
        model: DynamoDBMapperTableModel<Any>,
        tableName: String,
        objectToConditionCheck: Any,
        returnValuesOnConditionCheckFailure: ReturnValuesOnConditionCheckFailure?,
        writeExpression: DynamoDBTransactionWriteExpression?
    ): ConditionCheck? {
        val conditionCheck = ConditionCheck()
        conditionCheck.key = model.convertKey<Any, Any>(objectToConditionCheck)
        conditionCheck.tableName = tableName
        if (returnValuesOnConditionCheckFailure != null) {
            conditionCheck.returnValuesOnConditionCheckFailure = returnValuesOnConditionCheckFailure.toString()
        }
        if (writeExpression != null) {
            conditionCheck.conditionExpression = writeExpression.conditionExpression
            if (!writeExpression.expressionAttributeNames.isNullOrEmpty()) {
                conditionCheck.expressionAttributeNames = writeExpression.expressionAttributeNames
            }
            if (!writeExpression.expressionAttributeValues.isNullOrEmpty()) {
                conditionCheck.expressionAttributeValues = writeExpression.expressionAttributeValues
            }
        }
        return conditionCheck
    }

    private fun generateDelete(
        model: DynamoDBMapperTableModel<Any>,
        tableName: String,
        objectToDelete: Any,
        returnValuesOnConditionCheckFailure: ReturnValuesOnConditionCheckFailure?,
        writeExpression: DynamoDBTransactionWriteExpression?
    ): Delete? {
        val delete = Delete()
        delete.key = model.convertKey<Any, Any>(objectToDelete)
        delete.tableName = tableName
        if (returnValuesOnConditionCheckFailure != null) {
            delete.returnValuesOnConditionCheckFailure = returnValuesOnConditionCheckFailure.toString()
        }
        if (writeExpression != null) {
            if (writeExpression.conditionExpression != null) {
                delete.conditionExpression = writeExpression.conditionExpression
            }
            if (!writeExpression.expressionAttributeNames.isNullOrEmpty()) {
                delete.expressionAttributeNames = writeExpression.expressionAttributeNames
            }
            if (!writeExpression.expressionAttributeValues.isNullOrEmpty()) {
                delete.expressionAttributeValues = writeExpression.expressionAttributeValues
            }
        }
        return delete
    }

    fun getTableName(clazz: Class<*>?, `object`: Any?, config: DynamoDBMapperConfig?): String {
        return if (config!!.objectTableNameResolver != null && `object` != null) {
            config.objectTableNameResolver.getTableName(`object`, config)
        } else getTableName(clazz, config)
    }

    fun getTableName(clazz: Class<*>?, config: DynamoDBMapperConfig?): String {
        return if (config!!.tableNameResolver == null) {
            DynamoDBMapperConfig.DefaultTableNameResolver.INSTANCE.getTableName(clazz, config)
        } else config.tableNameResolver.getTableName(clazz, config)
    }

    private fun <T> toParameters(
        attributeValues: Map<String, AttributeValue>,
        modelClass: Class<T>,
        tableName: String,
        mapperConfig: DynamoDBMapperConfig?
    ): AttributeTransformer.Parameters<T>? {
        return toParameters(attributeValues, false, modelClass, tableName, mapperConfig)
    }

    private fun <T> toParameters(
        attributeValues: Map<String, AttributeValue>,
        partialUpdate: Boolean,
        modelClass: Class<T>,
        tableName: String,
        mapperConfig: DynamoDBMapperConfig?
    ): AttributeTransformer.Parameters<T>? {
        return TransformerParameters(
            mapper.getTableModel<T>(modelClass, mapperConfig),
            attributeValues,
            partialUpdate,
            modelClass,
            mapperConfig,
            tableName
        )
    }

    private class TransformerParameters<T>(
        private val model: DynamoDBMapperTableModel<T>,
        attributeValues: Map<String, AttributeValue>?,
        partialUpdate: Boolean,
        modelClass: Class<T>,
        mapperConfig: DynamoDBMapperConfig?,
        tableName: String
    ) : AttributeTransformer.Parameters<T> {
        private val attributeValues: Map<String, AttributeValue>
        private val partialUpdate: Boolean
        private val modelClass: Class<T>
        private val mapperConfig: DynamoDBMapperConfig?
        private val tableName: String
        override fun getAttributeValues(): Map<String, AttributeValue> {
            return attributeValues
        }

        override fun isPartialUpdate(): Boolean {
            return partialUpdate
        }

        override fun getModelClass(): Class<T> {
            return modelClass
        }

        override fun getMapperConfig(): DynamoDBMapperConfig? {
            return mapperConfig
        }

        override fun getTableName(): String {
            return tableName
        }

        override fun getHashKeyName(): String {
            return model.hashKey<Any>().name()
        }

        override fun getRangeKeyName(): String? {
            return if (model.rangeKeyIfExists<Any>() == null) null else model.rangeKey<Any>().name()
        }

        init {
            this.attributeValues = Collections.unmodifiableMap(attributeValues)
            this.partialUpdate = partialUpdate
            this.modelClass = modelClass
            this.mapperConfig = mapperConfig
            this.tableName = tableName
        }
    }

    private fun <T> canGenerate(
        model: DynamoDBMapperTableModel<T>,
        `object`: T,
        saveBehavior: DynamoDBMapperConfig.SaveBehavior,
        field: DynamoDBMapperFieldModel<T, Any?>
    ): Boolean {
        if (field.generateStrategy == null) {
            return false
        } else if (field.generateStrategy == DynamoDBAutoGenerateStrategy.ALWAYS) {
            return true
        } else if (field[`object`] != null) {
            return false
        } else if (field.keyType() != null || field.indexed()) {
            return true
        } else if (saveBehavior == DynamoDBMapperConfig.SaveBehavior.CLOBBER ||
            saveBehavior == DynamoDBMapperConfig.SaveBehavior.UPDATE ||
            saveBehavior == DynamoDBMapperConfig.SaveBehavior.PUT
        ) {
            return true
        } else if (anyKeyGeneratable(model, `object`, saveBehavior)) {
            return true
        }
        return false
    }

    private fun transformAttributes(
        parameters: AttributeTransformer.Parameters<Any>?
    ): Map<String, AttributeValue> {
        /* for our case transformer was always null, so skipped that if-else */
        return parameters!!.attributeValues
    }

    private fun <T> anyKeyGeneratable(
        model: DynamoDBMapperTableModel<T>,
        `object`: T,
        saveBehavior: DynamoDBMapperConfig.SaveBehavior
    ): Boolean {
        for (field in model.keys()) {
            if (canGenerate(model, `object`, saveBehavior, field)) {
                return true
            }
        }
        return false
    }
}
