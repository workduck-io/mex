# Welcome to Serverless!
#
# This file is the main config file for your service.
# It's very minimal at this point and uses default values.
# You can always add more config options for more control.
# We've included some commented out config examples here.
# Just uncomment any of them to get that config option.
#
# For full config options, check the docs:
#    docs.serverless.com
#
# Happy Coding!
service: mex-backend
# app and org for use with dashboard.serverless.com
#app: your-app-name
#org: your-org-name

# You can pin your service to only deploy with a specific Serverless version
# Check out our docs for more details
frameworkVersion: '2'

provider:
  name: aws
  runtime: java11
  stage: local
  region: ${opt:region, 'us-east-1'}
  lambdaHashingVersion: 20201221
  timeout: 20
  memorySize: 1024
  logRetentionInDays: 7
  environment:
    #AWS_ACCESS_KEY_ID: ${env:AWS_ACCESS_KEY_ID}
    #AWS_SECRET_ACCESS_KEY: ${env:AWS_SECRET_ACCESS_KEY}
    TABLE_NAME: ${opt:stage, 'local'}-mex
    JAVA_TOOL_OPTIONS: -XX:+TieredCompilation -XX:TieredStopAtLevel=1
    STAGE: ${opt:stage, 'local'}
    PUBLIC_NOTE_CACHE_READER_ENDPOINT:
      Fn::Join:
        - ''
        - - Ref: PublicNoteElasticCacheCluster
          - -ro.m6edlo.ng.0001.use1.cache.amazonaws.com
    PUBLIC_NOTE_CACHE_ENDPOINT:
      Fn::Join:
        -  ''
        - - Ref: PublicNoteElasticCacheCluster
          - .m6edlo.ng.0001.use1.cache.amazonaws.com
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - sqs:*
          Resource:
            Fn::GetAtt: [PublicNoteDLQ, Arn]
        - Effect: Allow
          Action:
            - dynamodb:Scan
            - dynamodb:Query
            - dynamodb:GetItem
            - dynamodb:PutItem
            - dynamodb:UpdateItem
            - dynamodb:DeleteItem
            - dynamodb:DescribeTable
            - dynamodb:BatchWriteItem
            - dynamodb:BatchGetItem
          Resource: 'arn:aws:dynamodb:us-east-1:*:*'
        - Effect: Allow
          Action:
            - 'lambda:InvokeFunction'
          Resource:
            - '*'
        - Effect: Allow
          Action:
            - dynamodb:DescribeStream
            - dynamodb:GetRecords
            - dynamodb:GetShardIterator
            - dynamodb:ListStreams
          Resource: 'arn:aws:dynamodb:us-east-1:*:table/*'
        - Effect: Allow
          Action:
            - 'cognito-idp:AdminGetUser'
            - 'cognito-idp:AdminUpdateUserAttributes'
          Resource:
            - 'arn:aws:cognito-idp:us-east-1:418506370286:userpool/*'
  httpApi:
    cors:
      allowedOrigins: 
        - "*"
      allowedHeaders:
        - Content-Type
        - X-Amz-Date
        - Authorization
        - X-Api-Key
        - X-Amz-Security-Token
        - X-Amz-User-Agent
        - X-Amzn-Trace-Id
        - mex-workspace-id
        - wd-request-id
    authorizers:
      mexAuthorizer:
        identitySource: $request.header.Authorization
        issuerUrl:
          Fn::Join:
            - ''
            - - 'https://cognito-idp.'
              - '${opt:region, self:provider.region}'
              - '.amazonaws.com/'
              - 'us-east-1_Zu7FAh7hj' #userpool id
        audience:
          - '6pvqt64p0l2kqkk2qafgdh13qe'
  logs:
    httpApi:
      # requestTime : time of request
      # requestId : unique ID given to the request by API Gateway.
      # httpMethod : GET/POST etc.
      # path : path with values of parameters
      # routeKey : routeKey
      # status : The status code returned by the response
      # responseLatency : The total time it took from when the request reached API Gateway to when the response was returned.
      # integrationRequestId : request ID for your Lambda function invocation
      # functionResponseStatus : status returned by the code in your Lambda function
      # integrationLatency : Latency of Lambda function
      # integrationServiceStatus : 200 is lambda is working correctly
      # authorizeResultStatus : 200 if it was allowed or a 403 if it was denied.
      # authorizerLatency: time taken by authorizer
      # ip : userIP
      # userAgent : userAgent
      # principalId : can use this to identify the user in your application making a request
      format: '{
      "requestTime":"$context.requestTime",
      "requestId":"$context.requestId",
      "httpMethod":"$context.httpMethod",
      "path":"$context.path",
      "routeKey":"$context.routeKey",
      "status":$context.status,
      "responseLatency":$context.responseLatency,
      "integrationRequestId":"$context.integration.requestId",
      "functionResponseStatus":"$context.integration.status",
      "integrationLatency":"$context.integration.latency",
      "integrationServiceStatus":"$context.integration.integrationStatus",
      "authorizeResultStatus":"$context.authorizer.status",
      "authorizerRequestId":"$context.authorizer.requestId",
      "authorizerLatency": "$context.authorizer.latency",
      "ip":"$context.identity.sourceIp",
      "userAgent":"$context.identity.userAgent",
      "principalId":"$context.authorizer.principalId"}'

package:
  artifact: target/mex-dev.jar

plugins:
  - serverless-dynamodb-local
  - serverless-offline
  - serverless-domain-manager
  - serverless-plugin-warmup
  - serverless-prune-plugin
custom:
  serverless-offline:
    noPrependStageInUrl: true
    useDocker: true
    ignoreJWTSignature: true
    noAuth: true
    httpPort: 4000
  warmup:
    officeHoursWarmer:
      enabled: true
      prewarm: true
      events:
        - schedule: cron(0/5 3-15 ? * MON-FRI *) # converted to UTC format -> IST : 8.30 am to 8.30 pm
      concurrency: 5
      role: IamRoleLambdaExecution
    outOfOfficeHoursWarmer:
      enabled: true
      prewarm: true
      events:
        - schedule: cron(0/15 15-23 ? * MON-FRI *) # 8.30 pm to 4.30 am IST
        - schedule: cron(0/15 0-3 ? * MON-FRI *) # left value should be lesser that right value
        - schedule: cron(0/15 * ? * SAT-SUN *)
      concurrency: 2
      role: IamRoleLambdaExecution
  customDomain:
    rest:
      domainName: api-${opt:stage, self:provider.stage}.workduck.io
      basePath: 'mex'
      stage: ${opt:stage, self:provider.stage}
      createRoute53Record: true
    http:
      domainName: http-${opt:stage, self:provider.stage}.workduck.io
      basePath: 'mex'
      stage: ${opt:stage, self:provider.stage}
      createRoute53Record: true
      endpointType: regional
      apiType: http

functions:
  - ${file(src/main/resources/rest-api-resources.yml)}


useDotenv: true

resources:
#  - Conditions:
#      IsProd:
#        Fn::Equals:
#          - ${opt:stage, 'local'}
#          - test
#
#      IsTest:
#        Fn::Not:
#          - Condition: IsProd

  - ${file(src/main/resources/api-gateway-errors.yml)}
#  - ${file(src/main/resources/prod-table-config.yml)}
  - ${file(src/main/resources/test-table-config.yml)}
  - ${file(src/main/resources/queue-resources.yml)}
  - ${file(src/main/resources/elasticache-resources.yml)}
